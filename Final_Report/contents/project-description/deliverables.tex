\subsection{Targeted Deliverables}
\label{sec-deliverables}

Here we will present how the deliverables are related to each other.
This allows us to briefly present each deliverable as well as why it
is relevant and was delved into. Let us start with the technical
deliverable.

\KB{include mindmap}

% \KB{rely on E4L use-case; understand \gls{ms} \& work with GL; etc} 

\subsubsection{Technical deliverables}

The main goal of our technical deliverable was to inspect how easy it
is to deploy a \gls{ms} given the \gls{e4l} application---which we
assume to be a monolithic application. Given the research presented in
section \vref{sd:ms}, we concluded that \gls{ms} would not be fitting
the architecture. Prior to working on this \gls{bsp}---as well as was
discovered and confirmed during the project while inspecting the
\gls{e4l} code---it was known that this application had the typical
front-end, back-end and database structure. There was also no notion
of services in the \gls{ms}-sense of the word.

% \KB{MONOLITHIC should be an assumption: list evidence leading to
% assumption + how it affected engineering of MS}.

Due to the fact that \glspl{ms} are supposed to be isolated
components, it was clear from the start that we should not modify the
original \gls{e4l} code for our purposes. In fact, given our use-case
of plotting an arbitrary graph using data provided by \gls{e4l}, our
best bet would be to rely on an API that is exposed or to connect to
its database directly. The worst scenario would be one where neither
were available; in this case we would have no other choice but
to make our own API by modifying the \gls{e4l} code or by creating a
wrapper around other functionality that is exposed by \gls{e4l}.

This technical deliverable will dive into the whole process that we
went through from the beginning until the moment we had the final
\gls{ms} up and running alongside \gls{e4l}. The way we conducted the
experiments at every step was a very iterative process. A little
research on a given matter would help us get familiar with a
particular topic as well as how to approach the implementation. We
would then create a dummy code to test said features and keep it
around as a reference in case something breaks in the main
implementation. From there it was a matter of fixing issues that arose
as well as adapting and refining the solution until we obtained the
product we sought to create. If further features were required, we
introduced them step by step by following this iterative process which
was accompanied by lots of dummy implementations for reference and
testing.

% \KB{define methodology for conducting experiments}

However, before being able to fully realise this task there were some
notions that we needed to acquire and get familiar with. First of all,
what even is a \gls{ms}? Further, given that we were working using
GitLab and wanted to take advantage of its \gls{cicd} framework, we
naturally wanted to find out how the concepts of DevOps and \glspl{ms}
are related---since \gls{cicd} is also employed in the DevOps context.


% {\color{gray}
% Provide a synthetic and abstract description of the technical deliverables that were targeted to be produced. 
% }

\subsubsection{Scientific deliverables}

The first scientific deliverable therefore consists in inspecting
what a \gls{ms} is. Given how \glspl{ms} are a fundamental part of of
this \gls{bsp} it was essential to learn about them and what is
considered to be a \gls{ms}. Once we had this notion we could expand
on it and construct a meaningful service.

The second deliverable consisted in finding out how DevOps plays a
role in the \gls{ms} philosophy. There were indeed quite a few aspects
that hinted at a correlation but we wanted to find out where and how
both interplay. This in turn would directly feed back into the
technical deliverable as we would obtain a better overview on the
overall structure and approach.

The \gls{ms} part was of importance in order to actually create the
service in question, while the DevOps side allowed us to automate our
solution and take care of the many manual steps needed to finally
deploy an application---which would be of great importance if we start
to manage more than one \gls{ms}.

% {\color{gray}
% Provide a synthetic and abstract description of the scientific deliverables that were targeted to be produced. 
% Each BSP must contain some work done according to the principles of the scientific method. It basically means that you should define at least one question related to the knowledge domain of your BSP and follow part of the scientific method process to answer to this question. The description of the work done to answer this question is a scientific deliverable.

% Examples of question could be:
% \begin{itemize}
%   \item Is Python an adequate language for concurrent programs?
%   \item How can we measure the ergonomic of a graphical user interface?
%   \item How can we ensure that a program will not fail?
% \end{itemize}

% An answer to such question should be the result of applying partly or totally the scientific method according to its standard definition which can be found in the literature.

% As you can see in this template, the scientific deliverable is entirely separated from the technical deliverable. Of course it addresses a question more or less closely related to the technical deliverable. 
% }
